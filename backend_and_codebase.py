# -*- coding: utf-8 -*-
"""backend and codebase.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zzJOVVs5TFtP52qx65jAa4CwHTVVrCXQ
"""

import pytz

# Set the desired timezone (e.g., 'Asia/Kolkata' for Indian Standard Time)
timezone = pytz.timezone('Asia/Kolkata')

import sqlite3
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Step 1: Set up the SQLite database
conn = sqlite3.connect('content_generation.db')
cursor = conn.cursor()

# Create the user table
cursor.execute('''
CREATE TABLE IF NOT EXISTS generation_data (
    user_id TEXT,
    prompt TEXT,
    image_path TEXT,
    status TEXT,
    generated_at TEXT,
    PRIMARY KEY (user_id, image_path)
)
''')
conn.commit()

# Function to insert a new record
def insert_initial_record(user_id, prompt, status="Processing"):
    generated_at = datetime.now(timezone).strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute('''
        INSERT INTO generation_data (user_id, prompt, image_path, status, generated_at)
        VALUES (?, ?, NULL, ?, ?)
    ''', (user_id, prompt, status, generated_at))
    conn.commit()

# Function to add paths for images and videos
def add_path_record(user_id, prompt, status, image_path=None):
    generated_at = datetime.now(timezone).strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute('''
        INSERT INTO generation_data (user_id, prompt, image_path, status, generated_at)
        VALUES (?, ?, ?, ?, ?)
    ''', (user_id, prompt, image_path, status, generated_at))
    conn.commit()

# Function to update the status
def update_status(user_id, status):
    generated_at = datetime.now(timezone).strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute('''
        UPDATE generation_data
        SET status = ?, generated_at = ?
        WHERE user_id = ? AND status != "Completed"
    ''', (status, generated_at, user_id))
    conn.commit()

# Function to notify the user
def notify_user(email, user_id):
    sender_email = "your_email@example.com"  # Replace with your email
    sender_password = "your_password"        # Replace with your email password

    # Email content
    subject = "Your Content is Ready!"
    body = f"Hello,\n\nYour generated content for User ID {user_id} is ready.\n\nBest regards,\nThe Team"

    # Set up the email
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = email
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))

    # Send the email
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
            print(f"Notification email sent to {email}.")
    except Exception as e:
        print(f"Failed to send email: {e}")

# # Example Usage
# insert_initial_record(
#     user_id="user123",
#     prompt="Generate a video about climate change"
# )

# # Simulate generating and adding individual paths
# add_path_record(
#     user_id="user123",
#     prompt="Generate a video about climate change",
#     status="Processing",
#     video_path="/path/to/video1.mp4"
# )
# add_path_record(
#     user_id="user123",
#     prompt="Generate a video about climate change",
#     status="Processing",
#     image_path="/path/to/image1.jpg"
# )
# add_path_record(
#     user_id="user123",
#     prompt="Generate a video about climate change",
#     status="Processing",
#     video_path="/path/to/video2.mp4",
#     image_path="/path/to/image2.jpg"
# )

# # Simulate marking the status as completed
# update_status(user_id="user123", status="Completed")
# notify_user(email="user@example.com", user_id="user123")

# # Close the database connection
# conn.close()

import random
import string
# function to generate a random string of numbers and letters to be alloted to each user
#each string will be unique
def generate_random_string(length=10):
    characters = string.ascii_letters + string.digits  # Letters (both uppercase and lowercase) + digits
    random_string = ''.join(random.choices(characters, k=length))
    return random_string

import os
import torch
from diffusers import StableDiffusionPipeline
from diffusers import DiffusionPipeline
from google.colab import drive
import requests
import openai

# Mount Google Drive for saving outputs
drive.mount('/content/drive')

def create_directory_structure(user_id):
    base_dir = f"generated_content/{user_id}"
    images_dir = os.path.join(base_dir, "images")
    videos_dir = os.path.join(base_dir, "videos")

    # Create directories if they don't exist
    os.makedirs(images_dir, exist_ok=True)
    os.makedirs(videos_dir, exist_ok=True)

    return images_dir, videos_dir

def generate_images(prompt, num_images, save_dir):
    """
    Generates an image based on a text prompt using Stable Diffusion.

    Args:
        prompt (str): Text prompt for image generation.
        output_path (str): File path to save the generated image.
        num_images(int): Number of images to generate.
    Returns:
        None
    """
    # Load the Stable Diffusion model pipeline
    pipe = StableDiffusionPipeline.from_pretrained("runwayml/stable-diffusion-v1-5", torch_dtype=torch.float16)

    device = "cuda" if torch.cuda.is_available() else "cpu"
    pipe = pipe.to(device)

    print(f"Generating images for prompt: {prompt}")
    for i in range(num_images):
        try:
            # Generate an image
            image = pipe(prompt).images[0]
            # Save the image
            image_path = os.path.join(save_dir, f"image_{i+1}.png")
            image.save(image_path)
            print(f"Image {i+1} saved at: {image_path}")
        except Exception as e:
            print(f"Error generating image {i+1}: {e}")


def generate_videos(video_inputted_prompt, num_videos, save_dir):
    """
    Generates multiple videos based on a prompt using the ViralAPI.

    Args:
        video_inputted_prompt (str): The prompt for video generation.
        num_videos (int): The number of videos to generate.
        save_dir (str): The directory to save the generated videos.
    """
    API_KEY = 'N9O1nX0o3IVqqv5slI65Qb2ugUYY9tf9oFBgPPv0K_c'
    url = 'https://viralapi.vadoo.tv/api/generate_video'
    headers = {
        'X-API-KEY': API_KEY,
        'Content-Type': 'application/json'
    }

    # Create the save directory if it doesn't exist
    os.makedirs(save_dir, exist_ok=True)

    for i in range(num_videos):
        data = {
            'topic': video_inputted_prompt,
            'language': 'English',
            'duration': '30-60'
        }

        response = requests.post(url, headers=headers, json=data)

        if response.status_code == 200 and response.headers.get('content-type') == 'application/json':
            try:
              response_data = response.json()
              video_id = response_data['vid']
              print(f"Video ID: {video_id}")

              # Download the video
              video_url = f"https://viralapi.vadoo.tv/api/video/{video_id}"  # Assuming this is the correct video URL format
              video_response = requests.get(video_url, stream=True)

              if video_response.status_code == 200:
                  # Save the video to a file
                  video_file_path = os.path.join(save_dir, f"{video_inputted_prompt}_{i + 1}.mp4")
                  with open(video_file_path, 'wb') as f:
                      for chunk in video_response.iter_content(chunk_size=8192):
                          f.write(chunk)
                  print(f"Video saved at: {video_file_path}")
              else:
                  print(f"Failed to download video. Status code: {video_response.status_code}")
            except (ValueError, KeyError) as e:
                print(f"Error parsing JSON response: {e}")
                print(f"Response content: {response.text}")


        else:
            print(f"Failed to generate video. Status code: {response.status_code}")
            print(response.text)
# Driver code
def main():
    # Input from the user
    user_id = input("Enter your user ID: ")
    prompt = input("Enter the text prompt: ")
    num = int(input())

    # Create directories
    images_dir, videos_dir = create_directory_structure(user_id)

    # updating the database with user input
    new_user_id = generate_random_string(length = 10)
    insert_initial_record(new_user_id, prompt)
    add_path_record(new_user_id, prompt, "Processing", images_dir)

    # Generate images
    generate_images(prompt, num, images_dir)

    update_status(new_user_id, "Completed")











if __name__ == "__main__":
    main()

cursor = conn.cursor()
cursor.execute("SELECT * FROM generation_data")
rows = cursor.fetchall()
for row in rows:
    print(row)
